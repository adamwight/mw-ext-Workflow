<?php namespace Workflow;

use \Exception;
use Workflow\Library\IMachineLibrary;

/**
 * Basic FSM engine supporting exceptions and preconditions
 *
 * An exception is just a shortcut notation for a transition exiting from every state.
 */
class StateMachine
	implements IStateMachine
{
	protected $state;

	protected $busy = false;
	protected $nextSignal;

	protected $context;

	protected $description;

	protected $libraries = array();

	function __construct( StateMachineDescription $desc ) {
		$this->description = $desc;
		$this->context = new Context();

		foreach ( $this->description->getLibraries() as $libraryName ) {
			$obj = new $libraryName();
			if ( !( $obj instanceof IMachineLibrary ) ) {
				throw new InvalidLibraryException( $libraryName );
			}
			$this->libraries[] = $obj;
		}
	}

	function begin() {
		$initialState = $this->description->getInitialState();
		$this->enterState( $initialState );
	}

	function signal( $name ) {
		if ( $this->isBusy() ) {
			// We only tolerate a one-signal queue, which we expect will be
			// potentially generated by an enterState action.
			$this->enqueueSignal( $name );
			return;
		}

		do {
			$this->doTransition( $name );

			// Catch up with signals that might have been generated during the transition
			$name = $this->nextSignal;
			$this->nextSignal = null;
		} while ( $name !== null );
	}

	function enqueueSignal( $name ) {
		if ( $this->nextSignal ) {
			// FIXME: new type of exception, "stack full" or something
			throw new BusyMachineException();
		}
		$this->nextSignal = $name;
	}

	protected function doTransition( $transition ) {
		if ( in_array( $transition, $this->description->getExceptions() ) ) {
			$destinationState = $this->description->getExceptionDestination( $transition );
		} elseif ( !in_array( $transition, $this->getAvailableTransitions() ) ) {
			throw new InvalidTransitionException( $this->getState(), $transition );
		} else {
			$destinationState = $this->description->getDestinationState( $this->getState(), $transition );
		}

		try {
			$this->exitState();

			$this->enterState( $destinationState );
		} catch ( TransitionNotPossibleException $ex ) {
			$this->state = $this->previousState;
			// TODO: reject transition, LOUDER

			$this->nextSignal = null;
		} catch ( Exception $ex ) {
			// TODO: $this->handleException( $ex );
			$this->nextSignal = null;

			throw $ex;
		}

		$this->setBusy( false );
	}

	function getTitle() {
		return $this->description->getTitle();
	}

	function getState() {
		return $this->state;
	}

	protected function exitState() {
		// TODO: begin transaction on context data
		// TODO: system-global mutex in the db, guarantee atomicity
		$this->setBusy( true );
		$this->previousState = $this->state;
	}

	protected function enterState( $state ) {
		$this->state = $state;

		$actionList = $this->description->getActionsForState( $state );
		foreach ( $actionList as $action => $params ) {
			$this->handleAction( $action, $params );
		}
	}

	protected function handleAction( $action, $params ) {
		foreach ( $this->libraries as $library ) {
			if ( in_array( $action, $library->getActions() ) ) {
				$library->handleAction( $this, $action, $params );
				return;
			}
		}

		throw new InvalidActionException( $action );
	}

	/**
	 * Retrieve a value from either the context, or from the
	 * description configuration.
	 */
	function getValue( $key ) {
		if ( $value = $this->context->getValue( $key ) ) {
			return $value;
		} else {
			return $this->description->getConfigurationValue( $key );
		}
	}

	function setValue( $key, $value ) {
		$this->context->setValue( $key, $value );
	}

	/**
	 * Returns all signals leading from the current node
	 */
	protected function getAvailableTransitions() {
		return $this->description->getTransitionsForState( $this->state );
	}

	function isBusy() {
		return $this->busy;
	}

	function isFinished() {
		return ( count( $this->getAvailableTransitions() ) == 0 );
	}

	protected function setBusy( $busy ) {
		if ( $busy ) {
			if ( $this->isBusy() ) {
				throw new BusyMachineException();
			}
			$this->busy = true;
		} else {
			// TODO: assert if double-unbusy
			$this->busy = false;
		}
	}

	function __sleep() {
		$this->setBusy( true );
	}

	function __wakeup() {
		$this->setBusy( false );
	}
}
